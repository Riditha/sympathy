
/*
 * This file is part of Sympathy
 * Copyright (c) 2017-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is JSONAPIClient is NotificationForwarder:

import capex.http
import capex.web

func forConfiguration(notificationForwarderConfig as DynamicMap) static as this
{
	assert notificationForwarderConfig
	var notificationForwarderBaseURL = notificationForwarderConfig.getString("notificationForwarderBaseURL")
	assert String.isNotEmpty(notificationForwarderBaseURL)
	var forwardURL = notificationForwarderConfig.getString("forwardURL")
	assert String.isNotEmpty(forwardURL)
	var accessTokenKey = notificationForwarderConfig.getString("accessTokenKey")
	assert String.isNotEmpty(accessTokenKey)
	var accessToken = notificationForwarderConfig.getString("accessToken")
	assert String.isNotEmpty(accessToken)
	var v = new this()
	v.setNotificationForwarderBaseURL(notificationForwarderBaseURL)
	v.setForwardURL(forwardURL)
	v.setAccessTokenKey(accessTokenKey)
	v.setAccessToken(accessToken)
	return v
}

ctor:
	setWebClient(new CustomWebClient())

prop notificationForwarderBaseURL as string
prop accessTokenKey as string
prop accessToken as string
prop forwardURL as string

func getFullURL(api as string) override as string
{
	var url = notificationForwarderBaseURL
	if String.isEmpty(url):
		url = "/"
	if url == "/" {
		if String.startsWith(api, "/"):
			return api
		return url .. api
	}
	if String.endsWith(url, "/") {
		if String.startsWith(api, "/"):
			return url .. String.getSubString(api, 1)
		return url .. api
	}
	if String.startsWith(api, "/"):
		return url .. api
	return url .. "/" .. api
}

func get(url as string, headers as KeyValueList<string,string>, callback as function<void, DynamicMap, Error>) private
{
	doSendRequest("GET", getFullURL(url), headers, null, func(responseHeaders as KeyValueList<string,string>, body as buffer) {
		assert body:
			callback(null, Error.instance("failed_to_connect", "Failed to connect to server"))
		var json = assert JSONParser.parse(body) as DynamicMap:
			callback(null, Error.forMessage("Invalid JSON Format from notification forward server: '" .. String.asString(body) .. "'"))
		callback(json, null)
	}, func(error as Error) {
		callback(null, error)
	})
}

func post(url as string, headers as KeyValueList<string,string>, data as DynamicMap, callback as function<void, DynamicMap, Error>) private
{
	doSendRequest("POST", getFullURL(url), headers, String.toUTF8Buffer(JSONEncoder.encode(data)), func(responseHeaders as KeyValueList<string,string>, body as buffer) {
		assert body:
			callback(null, Error.instance("failed_to_connect", "Failed to connect to server"))
		var json = assert JSONParser.parse(body) as DynamicMap:
			callback(null, Error.forMessage("Invalid JSON Format from notification forward server: '" .. String.asString(body) .. "'"))
		callback(json, null)
	}, func(error as Error) {
		callback(null, error)
	})
}

func put(url as string, headers as KeyValueList<string,string>, data as DynamicMap, callback as function<void, DynamicMap, Error>) private
{
	doSendRequest("PUT", getFullURL(url), headers, String.toUTF8Buffer(JSONEncoder.encode(data)), func(responseHeaders as KeyValueList<string,string>, body as buffer) {
		assert body:
			callback(null, Error.instance("failed_to_connect", "Failed to connect to server"))
		var json = assert JSONParser.parse(body) as DynamicMap:
			callback(null, Error.forMessage("Invalid JSON Format from notification forward server: '" .. String.asString(body) .. "'"))
		callback(json, null)
	}, func(error as Error) {
		callback(null, error)
	})
}

func delete(url as string, headers as KeyValueList<string,string>, callback as function<void, DynamicMap, Error>) private
{
	doSendRequest("DELETE", getFullURL(url), headers, null, func(responseHeaders as KeyValueList<string,string>, body as buffer) {
		assert body:
			callback(null, Error.instance("failed_to_connect", "Failed to connect to server"))
		var json = assert JSONParser.parse(body) as DynamicMap:
			callback(null, Error.forMessage("Invalid JSON Format from notification forward server: '" .. String.asString(body) .. "'"))
		callback(json, null)
	}, func(error as Error) {
		callback(null, error)
	})
}

func forward(data as DynamicMap, callback as function<void, DynamicMap, Error>)
{
	assert data:
		callback(null, Error.instance("no_notification_data", "No notification data"))
	var headers = new KeyValueList<string,string>()
	if String.isNotEmpty(accessTokenKey) && String.isNotEmpty(accessToken):
		headers.add(accessTokenKey, accessToken)
	headers.add("Content-Type", "application/json")
	post(forwardURL, headers, data, func(response as DynamicMap, e as Error) {
		assert not e:
			callback(null, e)
		callback(response, null)
	})
}
