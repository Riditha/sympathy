
/*
 * This file is part of Sympathy
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 * Copyright (c) 2018 Eqela Oy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

class is WebServerWithDatabase:

import sympathy
import sympathy.dbapp
import capex.data

var smtpServer as string
var validationEmailTemplateFile as File
var recoveryEmailTemplateFile as File

func configure(key as string, value as string, relativeTo as File, error as Error) override as bool
{
	if key == "smtpServer" {
		smtpServer = value
		return true
	}
	if key == "validationEmailTemplate" {
		validationEmailTemplateFile = File.forRelativePath(value, relativeTo)
		return true
	}
	if key == "recoveryEmailTemplate" {
		recoveryEmailTemplateFile = File.forRelativePath(value, relativeTo)
		return true
	}
	return base.configure(key, value, relativeTo, error)
}

func initializeDatabase as bool
{
	var user = SQLTableInfo.forName("auth_user")
	user.addStringKeyColumn("id")
	user.addLongColumn("created")
	user.addStringColumn("password")
	user.addIndex("id")
	assert ensureTableExists(user)
	var userAddress = SQLTableInfo.forName("auth_user_address")
	userAddress.addStringColumn("address")
	userAddress.addStringColumn("userid")
	userAddress.addLongColumn("created")
	userAddress.addUniqueIndex("address")
	userAddress.addIndex("userid")
	assert ensureTableExists(userAddress)
	var session = SQLTableInfo.forName("auth_session")
	session.addStringColumn("id")
	session.addLongColumn("created")
	session.addLongColumn("accessed")
	session.addStringColumn("userid")
	session.addIndex("id")
	session.addIndex("userid")
	session.addIndex("accessed")
	assert ensureTableExists(session)
	var validation = SQLTableInfo.forName("auth_validation")
	validation.addStringColumn("address")
	validation.addStringColumn("secret")
	validation.addStringColumn("userid")
	validation.addLongColumn("created")
	validation.addIndex("address")
	validation.addIndex("secret")
	validation.addIndex("created")
	assert ensureTableExists(validation)
	var recovery = SQLTableInfo.forName("auth_recovery")
	recovery.addStringColumn("address")
	recovery.addStringColumn("secret")
	recovery.addStringColumn("userid")
	recovery.addLongColumn("created")
	recovery.addIndex("address")
	recovery.addIndex("secret")
	recovery.addIndex("created")
	assert ensureTableExists(recovery)
	return true
}

func initializeServer(server as HTTPServer) override as bool
{
	assert base.initializeServer(server)
	assert initializeDatabase()
	var handler = new ApiHandler()
	handler.setDb(getDb())
	if String.isNotEmpty(smtpServer) {
		var sender = SMTPSender.forRemoteServerUrl(smtpServer)
		sender.setAcceptInvalidCertificate(true)
		sender.setCtx(ctx)
		handler.setSmtpSender(sender)
	}
	else {
		Log.warning(ctx, "No smtpServer defined. No emails will be sent.")
	}
	if validationEmailTemplateFile {
		var cc = assert validationEmailTemplateFile.getContentsUTF8():
			Log.error(ctx, "Failed to read email template file: `" .. validationEmailTemplateFile.getPath() .. "'")
		handler.setValidationEmailTemplate(cc)
	}
	else {
		Log.warning(ctx, "No validationEmailTemplate set. No validation emails will be sent.")
	}
	if recoveryEmailTemplateFile {
		var cc = assert recoveryEmailTemplateFile.getContentsUTF8():
			Log.error(ctx, "Failed to read email template file: `" .. recoveryEmailTemplateFile.getPath() .. "'")
		handler.setRecoveryEmailTemplate(cc)
	}
	else {
		Log.warning(ctx, "No recoveryEmailTemplate set. No recovery emails will be sent.")
	}
	server.pushRequestHandler(handler)
	return true
}

main:
	return new this().executeMain(args)
