
/*
 * This file is part of Sympathy
 * Copyright (c) 2017-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class:

import capex.crypto

class Service
{
	prop file as File
	prop fileTimeStamp as long
	prop process as Process
	prop ctx as LoggingContext

	func matches(ff as File) as bool
	{
		assert ff
		if ff.isSame(file):
			return true
		return false
	}

	func getDisplayName as string
	{
		if not file:
			return "<unknown>"
		return file.baseName()
	}

	func terminate
	{
		if process {
			if process.isRunning() {
				Log.debug(ctx, "Terminating service process `" .. getDisplayName() .. "' ..")
				process.killForce()
				process.waitForExit()
				Log.debug(ctx, "Service process `" .. getDisplayName() .. " terminated.")
			}
			process = null
		}
	}

	func restart as bool
	{
		terminate()
		assert file:
			Log.error(ctx, "restart: No file")
		fileTimeStamp = file.getLastModifiedTimeStamp()
		var pl = assert ProcessLauncher.forFile(file):
			Log.error(ctx, "Failed to create a process launcher for file: `" .. file.getPath() .. "'")
		Log.debug(ctx, "Starting service process: `" .. getDisplayName() .. "'")
		assert process = pl.start():
			Log.error(ctx, "Failed to start service process: `" .. getDisplayName() .. "'")
		return true
	}

	func hasDied as bool
	{
		if not process:
			return true
		if process.isRunning() == false:
			return true
		return false
	}

	func hasFileChanged as bool
	{
		assert file
		if file.getLastModifiedTimeStamp() != fileTimeStamp:
			return true
		return false
	}
}

func forDirectory(dir as File) static as this
{
	var v = new this()
	v.setDirectory(dir)
	return v
}

prop directory as File
prop ctx as LoggingContext
var exitFlag = false
var directoryIdent as string
var services = new vector<Service>

func haveDirectoryContentsChanged private as bool
{
	assert directory
	var sb = new StringBuilder()
	var it = directory.entries()
	while it {
		var ee = it.next()
		if not ee:
			break
		if sb.count() > 0:
			sb.append('\n')
		sb.append(ee.baseName())
	}
	var ss = sb.toString()
	if String.isEmpty(ss):
		ss = "\n__emptyDirectory__\n"
	var ident = MD5Encoder.encode(ss)
	if directoryIdent == null || String.equals(ident, directoryIdent) == false {
		Log.debug(ctx, "Old directory ident: `" .. directoryIdent .. "'")
		Log.debug(ctx, "New directory ident: `" .. ident .. "'")
		directoryIdent = ident
		return true
	}
	return false
}

func onDirectoryContentsChanged private
{
	var existing = services
	var updated = new vector<Service>
	var it = directory.entries()
	while it {
		var ee = it.next()
		if not ee:
			break
		var nn = ee.baseName()
		if String.endsWith(nn, ".service") || String.contains(nn, ".service.") {
			var match as Service
			foreach ex in existing {
				if ex.matches(ee) {
					match = ex
					break
				}
			}
			if match {
				updated += match
				Vector.removeValue(existing, match)
			}
			else {
				var no = new Service()
				no.setFile(ee)
				no.setCtx(ctx)
				Log.debug(ctx, "Adding and starting new a service: `" .. no.getDisplayName() .. "'")
				no.restart()
				updated += no
			}
		}
	}
	foreach pp in existing {
		Log.debug(ctx, "Terminating a removed service: `" .. pp.getDisplayName() .. "'")
		pp.terminate()
	}
	services = updated
}

func execute as bool
{
	assert directory:
		Log.error(ctx, "No directory given to ServiceManager")
	Log.debug(ctx, "ServiceManager main loop starting.")
	loop {
		if exitFlag {
			Log.info(ctx, "Exit has been requested. Breaking out of ServiceManager main loop.")
			break
		}
		Log.debug(ctx, "ServiceManager cycle start")
		if haveDirectoryContentsChanged() {
			Log.debug(ctx, "ServiceManager directory contents changed.")
			onDirectoryContentsChanged()
		}
		foreach service in services {
			if service.hasFileChanged() {
				Log.debug(ctx, "Service file for `" .. service.getDisplayName() .. "' has changed. Restarting..")
				service.restart()
			}
			else if service.hasDied() {
				Log.debug(ctx, "Service `" .. service.getDisplayName() .. "' has died. Restarting..")
				service.restart()
			}
		}
		Log.debug(ctx, "ServiceManager cycle end")
		CurrentThread.sleepSeconds(5)
	}
	Log.debug(ctx, "ServiceManager main loop ended.")
	return true
}

func terminate
{
	exitFlag = true
	Log.debug(ctx, "ServiceManager exit flag has been set.")
}
