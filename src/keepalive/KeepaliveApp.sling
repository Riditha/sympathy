
/*
 * This file is part of Sympathy
 * Copyright (c) 2017-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class:

import capex.console

IFDEF "target_mono" {
	depend "dll:Mono.Posix.dll"

	class SignalMonitorThread is Runnable
	{
		prop app as parent
		prop ctx as ConsoleApplicationContext

		func run
		{
			Log.debug(ctx, "Signal monitor thread started.")
			loop {
				Log.debug(ctx, "Signal monitor thread waiting for signals.")
				var index as int
				lang "cs" {{{
					Mono.Unix.UnixSignal[] signals = new Mono.Unix.UnixSignal[] {
						new Mono.Unix.UnixSignal(Mono.Unix.Native.Signum.SIGTERM),
						new Mono.Unix.UnixSignal(Mono.Unix.Native.Signum.SIGINT)
					};
					index = Mono.Unix.UnixSignal.WaitAny(signals);
				}}}
				if index >= 0 {
					app.onExitRequestSignal()
					break
				}
			}
			Log.debug(ctx, "Signal monitor thread ended.")
		}
	}
}

func main(args as array<string>) static as int #main
{
	if new this().execute(args) == false:
		return 1
	return 0
}

prop exitFlag = false
prop process as Process
prop serviceManager as ServiceManager
var ctx as ConsoleApplicationContext

func printUsage(stdout as PrintWriter)
{
	var parameters = [
		[ "command", "The command to execute, along with any arguments" ]
	]
	var flags = [
		[ "bg|background", "Execute the command in the background" ],
		[ "quiet", "Suppress all output messages from the keepalive process" ],
		[ "debug", "Display debug information" ],
		[ "h|help", "Usage information" ]
	]
	var options = [
		[ "services", "Specify a service directory" ]
	]
	ConsoleApplication.printUsage(stdout, null, parameters, flags, options)
}

func onExitRequestSignal
{
	Log.info(ctx, "Exit request signal was received.")
	exitFlag = true
	if process:
		process.kill(5)
	if serviceManager:
		serviceManager.terminate()
}

func execute(args as array<string>) as bool
{
	var stdout = Stdout.instance()
	ctx = new ConsoleApplicationContext()
	var showHelp = false
	var background = false
	var command as string
	var commandArgs as vector<string>
	var serviceDir as File
	foreach arg in ConsoleApplication.parseCommandLineArguments(args) {
		if not command {
			if arg.isFlag("help") || arg.isFlag("h") {
				showHelp = true
				continue
			}
			if arg.isFlag("bg") || arg.isFlag("background") {
				background = true
				continue
			}
			if arg.isFlag("debug") {
				if ctx:
					ctx.setEnableDebugMessages(true)
				continue
			}
			if arg.isFlag("quiet") {
				ctx = null
				continue
			}
			if arg.isOption("services") {
				serviceDir = File.forPath(arg.getStringValue())
				continue
			}
		}
		var str = arg.getComplete()
		if String.isEmpty(str):
			continue
		if not command {
			command = str
			commandArgs = new vector<string>
		}
		else {
			commandArgs += str
		}
	}
	if command && serviceDir {
		Log.error(ctx, "You cannot specify both a command and a service directory.")
		return false
	}
	if((command == null && serviceDir == null) || showHelp) {
		ConsoleApplication.PRINT_HEADER(stdout, null)
		printUsage(stdout)
		return true
	}
	if background {
		var pl = ProcessLauncher.forSelf()
		if not pl {
			Log.error(ctx, "Failed to create a process launcher")
			return false
		}
		pl.addToParams("-quiet")
		if serviceDir:
			pl.addToParams("-services=" .. serviceDir.getPath())
		if command {
			pl.addToParams(command)
			foreach arg in commandArgs:
				pl.addToParams(arg)
		}
		if pl.start() == null {
			Log.error(ctx, "Failed to create a new background process")
			return false
		}
		return true
	}
	IFDEF "target_mono" {
		Thread.start(new SignalMonitorThread().setCtx(ctx).setApp(this))
	}
	var v = true
	if serviceDir {
		serviceManager = ServiceManager.forDirectory(serviceDir)
		serviceManager.setCtx(ctx)
		v = serviceManager.execute()
	}
	else {
		var pl = ProcessLauncher.forCommand(command)
		if not pl {
			Log.error(ctx, "Failed to create a process launcher for command: `" .. command .. "'")
			return false
		}
		foreach arg in commandArgs:
			pl.addToParams(arg)
		loop {
			Log.info(ctx, "Executing: `" .. pl.toString() .. "'")
			var startTime = SystemClock.asSeconds()
			process = pl.start()
			if not process {
				Log.error(ctx, "Process failed to start.")
			}
			else {
				var r = process.waitForExit()
				process = null
				Log.info(ctx, "Process exited: " .. String.forInteger(r))
			}
			if exitFlag {
				Log.info(ctx, "Exit has been requested. Ending process.")
				break
			}
			if SystemClock.asSeconds() - startTime < 5 {
				Log.warning(ctx, "Process lived for less than five seconds. Waiting for five seconds before restarting ..")
				CurrentThread.sleepSeconds(5)
			}
		}
	}
	Log.debug(ctx, "Exiting application.")
	return v
}
